<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
    <link rel="icon" href="/images/favicon.ico">
  
  <title>Hexo</title>
  
<link rel="stylesheet" href="/css/styles.css">

  
<script src="/lib/jquery.js"></script>

  
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">

  
<script src="/js/common.js"></script>

  
<script src="/lib/bootstrap/js/bootstrap.js"></script>

  
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

  <body>
    <header class="header">
  <div class="color-bar">
    <ul>
      <li class="bar1"></li>
      <li class="bar2"></li>
      <li class="bar3"></li>
      <li class="bar4"></li>
      <li class="bar5"></li>
      <li class="bar6"></li>
    </ul>
  </div>
  <div class="header-wrapper">
    <div class="blog-title">
      
        <img class="logo" src="/images/logo.png" alt="logo">
      
      <a href="/" class="title">Hexo</a>
    </div>
    <nav class="navbar navbar-menu">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" id="nav-btn" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
      </div>
        <ul class="menu menu-pc">
          
            <li class="menu-item">
              <a href="/homes" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
            </li>
          
            <li class="menu-item">
              <a target="_blank" rel="noopener" href="https://github.com/xyunyun" class="menu-item-link"><i class="fa fa-github"></i><span>Github</span></a>
            </li>
          
        </ul>
    </nav>
  </div>
</header>
<div class="collapse nav-collapse" style="position:fixed;top:59px;" id="bs-example-navbar-collapse-1">
  <ul class="menu menu-mobile" style="list-style:none">
    
      <li class="menu-item">
        <a href="/homes" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
      </li>
    
      <li class="menu-item">
        <a target="_blank" rel="noopener" href="https://github.com/xyunyun" class="menu-item-link"><i class="fa fa-github"></i><span>Github</span></a>
      </li>
    
  </ul>
</div>

    <main class="main">
      <div class="content">
        
  <article class="post">
    <!-- <div class="post-title">
      <h2 class="title">前端面试题</h2>
       
    </div> -->
     <div class="post-meta">
      <span class="post-time">2021-06-28</span>
    </div>
    <div class="post-content">
      <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show"><code>v-if</code> vs <code>v-show</code></a></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS display 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p>创建阶段<br>beforeCreate<br>实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性。<br>created<br>实例已经在内存中创建完毕，此时data和methods已经创建完成，此时还没有开始编译模板。<br>挂载阶段<br>beforeMount<br>此时已经完成了模板的编译，但是还没有挂载到页面中。<br>mounted<br>此时已经将编译好的模板挂载到了页面指定的容器中显示。<br>运行阶段<br>boforeUpdate<br>状态更新之前执行此类函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点。<br>updated<br>实例更新完毕之后调用此函数，此时data中的状态值和页面上显示的数据都已经完成了更新，界面已经被重新渲染好了。<br>销毁阶段<br>beforeDestroy<br>实例销毁之前调用，在这一步，实例仍然完全可用。<br>destroyed<br>Vue实例销毁后调用，调用后Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁</p>
<h2 id="vue双向数据绑定原理"><a href="#vue双向数据绑定原理" class="headerlink" title="vue双向数据绑定原理"></a>vue双向数据绑定原理</h2><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h2 id="vue单向数据流"><a href="#vue单向数据流" class="headerlink" title="vue单向数据流"></a>vue单向数据流</h2><h2 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h2><p>Virtual DOM是JS对象去描述DOM节点，vue中由 Vue 组件树建立起来的整个 VNode 树，经过Vnode的create、diff算法、patch等过程映射到真实的DOM，包含标签名，标签上的属性，事件监听和子元素们及属性，<br>原理：为了解决浏览器的性能问题，真正的DOM元素非常庞大，js的操作速度更快。<br>减少了DOM操作，可以跨平台渲染</p>
<h2 id="一个组件的data选项必须是一个函数"><a href="#一个组件的data选项必须是一个函数" class="headerlink" title="一个组件的data选项必须是一个函数"></a>一个组件的data选项必须是一个函数</h2><p>为了组件的复用，对象是一个引用数据类型，如果data是一个对象的情况下会造成所有组件共用一个data。而当data是一个函数的情况下，每次函数执行完毕后都会返回一个新的对象，这样的话每个组件都会维护一份独立的对象</p>
<h2 id="vue中组件之间的传值通信"><a href="#vue中组件之间的传值通信" class="headerlink" title="vue中组件之间的传值通信"></a>vue中组件之间的传值通信</h2><p>父组件向子组件传值：</p>
<ul>
<li>子组件在props中创建一个属性，用来接收父组件传来的值；</li>
<li>在父组件中注册子组件；</li>
<li>在子组件标签中添加props中创建的属性；把需要传给子组件的值赋给该属性</li>
</ul>
<p>子组件向父组件传值：</p>
<ul>
<li>子组件中以某种方法（如点击事件）触发一个自定义的事件；</li>
<li>将需要传的值作为$emit的第二个参数，该值将作为实参传给响应事件的方法</li>
</ul>
<h2 id="计算属性和侦听属性"><a href="#计算属性和侦听属性" class="headerlink" title="计算属性和侦听属性"></a>计算属性和侦听属性</h2><p>计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值；</p>
<p>watch选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的</p>
<h2 id="Vuex是什么"><a href="#Vuex是什么" class="headerlink" title="Vuex是什么"></a>Vuex是什么</h2><ul>
<li><p>Vuex 是一个专为 Vue.js 开发的状态管理模式，Vuex 应用的核心就是 store</p>
</li>
<li><p>“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)</p>
</li>
<li><p>state 就是<strong>数据源存放地</strong>，对应于⼀般 vue 对象⾥⾯的 data</p>
</li>
<li><p>Mutation  更改 Vuex 的 store 中的状态的<strong>方法</strong>是提交 mutation</p>
</li>
<li><p>getter可以认为是 store 的计算属性。getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
</li>
<li><p>Action 类似于 mutation，不同在于：</p>
<p>Action 提交的是 mutation，而不是直接变更状态,数据改变不能被追踪到。</p>
<p>Action 可以包含任意异步操作</p>
</li>
<li><p>Modules<strong>模块</strong>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</p>
</li>
</ul>
<p>适用情况</p>
<ul>
<li>当一个组件需要多次派发事件时。例如购物车数量加减。</li>
<li>跨组件共享数据、跨页面共享数据。例如订单状态更新。</li>
<li>需要持久化的数据。例如登录后用户的信息。</li>
<li>适用于多模块、业务关系复杂的中大型项目</li>
</ul>
<p>vuex-along （持久化存储 state 的 vuex 扩展常用于刷新网页后自动恢复 state）</p>
<h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><h3 id="router与-route"><a href="#router与-route" class="headerlink" title="$router与$route"></a>$router与$route</h3><p>$ruter是VueRouter的实例，路由操作对象，只写对象，包含了一些路由跳转方法，钩子函数等<br>$route是路由信息对象，只读对象，主要包含路由的基本信息。</p>
<h3 id="路由组件传参的3种方式"><a href="#路由组件传参的3种方式" class="headerlink" title="路由组件传参的3种方式"></a>路由组件传参的3种方式</h3><p>1.可以手写完整的path：this.$router.push({path:<code>/user/$&#123;userId&#125;</code>})<br>2.用params传递：是针对name的<br>3.用query传递：是针对path的</p>
<h3 id="vue-router的3种模式"><a href="#vue-router的3种模式" class="headerlink" title="vue-router的3种模式"></a>vue-router的3种模式</h3><p>默认hash模式：使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会改变<br>hisory模式：利用hisory.pushState</p>
<h2 id="hash和history的实现原理"><a href="#hash和history的实现原理" class="headerlink" title="hash和history的实现原理"></a>hash和history的实现原理</h2><h2 id="vm-set-解决对象新增属性不响应"><a href="#vm-set-解决对象新增属性不响应" class="headerlink" title="vm.$set()解决对象新增属性不响应"></a>vm.$set()解决对象新增属性不响应</h2><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h2 id="vue过滤器"><a href="#vue过滤器" class="headerlink" title="vue过滤器"></a>vue过滤器</h2><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>用于保留组件状态,会缓存不活动的组件实例，而不是销毁它们;<br>避免组件重新渲染。自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>
<h2 id="Vue-nextTick-的原理和用途"><a href="#Vue-nextTick-的原理和用途" class="headerlink" title="Vue.nextTick 的原理和用途"></a>Vue.nextTick 的原理和用途</h2><p>把回调函数放入callbacks等待执行<br>将执行函数放到微任务或者宏任务中<br>事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调<br>用法：<br>在下次 DOM 更新循环结束之后执行延迟回调;在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><h2 id="Element-UI-实现管理系统页面权限控制"><a href="#Element-UI-实现管理系统页面权限控制" class="headerlink" title="Element UI 实现管理系统页面权限控制"></a>Element UI 实现管理系统页面权限控制</h2><p>1 创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</p>
<p>2 当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</p>
<p>3 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</p>
<p>4 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p>
<h2 id="proxy与object-defineProperty"><a href="#proxy与object-defineProperty" class="headerlink" title="proxy与object.defineProperty"></a>proxy与object.defineProperty</h2><h1 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">ECMAScript 6</a></h1><h2 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h2><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型（栈数据）Number String Boolean Undefind null Symbol</p>
<p>引用值（堆数据） Array Object function</p>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h2 id="为什么是单线程"><a href="#为什么是单线程" class="headerlink" title="为什么是单线程"></a>为什么是单线程</h2><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>只针对像 Object, Array 这样的复杂对象的</p>
<p>浅度拷贝：复制一层对象的属性，更深层次对象级别的只是拷贝引用，当改变拷贝的对象里面的引用类型时，源对象也会改变。<strong>Object.assign()</strong> </p>
<p>深度拷贝：重新开辟一个内存空间，需要递归拷贝对象里的引用，直到子属性都为基本类型。两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p>
<p>**<code>instanceof</code>**运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>防抖，在事件触发指定时间之后才会执行相应的处理，若在这指定时间内事件又被调用，则会重新计时执行。对于短时间内连续触发的事件在一定时间期限内，事件处理函数只执行一次。</p>
<p>节流如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个实例对象（ object ）都有一个私有属性（__ proto__ ）指向它的构造函数的原型对象（<strong>prototype</strong> ）的链。<br>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾null。</p>
<h2 id="call-、apply-区别"><a href="#call-、apply-区别" class="headerlink" title="call()、apply()区别"></a>call()、apply()区别</h2><p><strong><code>call()</code></strong> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或类数组对象)的形式提供的参数</p>
<p><code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包指有权访问另一个函数作用域中变量的<strong>函数</strong>，</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>闭包可以使在一个内层函数中访问到其外层函数的作用域，延伸了变量的作用范围，</p>
<p>使用闭包来模拟私有方法。私有方法有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>
<p>闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</p>
<p>递归</p>
<p>调用自身的函数我们称之为<em>递归函数</em></p>
<h2 id="网页从打开到加载"><a href="#网页从打开到加载" class="headerlink" title="网页从打开到加载"></a>网页从打开到加载</h2><p><strong>1.进行DNS 解析</strong><br>浏览器首先搜索浏览器自身缓存的 DNS 记录。<br>如果浏览器缓存中没有找到需要的记录或记录已过期，则搜索 hosts 文件和操作缓存。<br>如果在 hosts 文件和操作系统缓存中没有找到需要的记录或记录已经过期，则向域名解析服<br>务器发送解析请求。<br>如果域名解析服务器也没有该域名的记录，则开始 递归 + 迭代 解析。<br>获取域名对应的IP后，一步步向上返回，直到返回给浏览器。<br>浏览器获取到 url 的 IP 地址。</p>
<p><strong>2.发起TCP请求</strong><br>建立TCP连接的过程就是三次握手过程：客户端向服务器端发送连接请求的报文。<br>服务器端收到请求后，同意建立连接，向客户端发送确认报文。<br>客户端收到服务器端的确认报文后，再次向服务器端发出报文，确认已收到确认报文。<br>浏览器与服务器已经建立了TCP连接，开始进行通信。</p>
<p><strong>3.浏览器向服务器发送http请求</strong><br>例如：浏览器发出取文件指令GET，HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体，POST方法用于将实体提交到指定的资源，PUT方法用请求有效载荷替换目标资源的所有当前表示，DELETE方法删除指定的资源，PATCH方法用于对资源应用部分修改，TRACE方法沿着到目标资源的路径执行一个消息环回测试，OPTIONS方法用于描述目标资源的通信选项，CONNECT方法建立一个到由目标资源标识的服务器的隧道。</p>
<p><strong>4.负载均衡</strong><br>什么是负载均衡？当一台服务器无法支持大量的用户访问时，将用户分摊到两个或多个服务器上<br>的方法叫负载均衡。<br>如果我们的平台配备了负载均衡的话，前一步 DNS 解析获得的IP地址应该是我们 Nginx 负<br>载均衡服务器的 IP 地址。所以，我们的浏览器将我们的网页请求发送到了 Nginx 负载均<br>衡服务器上。<br>Nginx 根据我们设定的分配算法和规则，选择一台后端的真实 Web 服务器，与之建立<br>TCP 连接、并转发我们浏览器发出去的网页请求。<br>Web 服务器收到请求，产生响应，并将网页发送给 Nginx 负载均衡服务器。<br>Nginx 负载均衡服务器将网页传递给 filters 链处理，之后发回给我们的浏览器。</p>
<p><strong>5.服务器响应http请求，将请求的指定资源发送给浏览器</strong></p>
<p>浏览器释放TCP连接<br>建立TCP连接的过程就是四次挥手过程：<br>浏览器向服务器发送释放连接报文。<br>服务器收到释放报文后，发出确认报文，然后将服务器上未传送完的数据发送完。<br>服务器数据传输完成后，向浏览器发送释放连接请求。<br>浏览器收到报文后，发出确认，然后等待一段时间后，释放TCP连接。</p>
<p><strong>6.浏览器渲染</strong> </p>
<p>浏览器根据页面内容，生成 DOM Tree 。根据 CSS 内容，生成 CSS Rule Tree (规则树)。<br>调用 JS 执行引擎执行 JS 代码。<br>根据 DOM Tree 和 CSS Rule Tree 生成 Render Tree (呈现树)。 3. 根据 Render Tree 渲染网页。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h2 id="移动端的适配"><a href="#移动端的适配" class="headerlink" title="移动端的适配"></a>移动端的适配</h2>
    </div>
  </article>
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
        <a href="/2021/02/03/note/" rel="next" title="note">
          <i class="fa fa-chevron-left"></i> note
        </a>
      
    </div>

    <span class="post-nav-divider"></span>

    <div class="post-nav-prev post-nav-item">
    
    </div>
  </div>

<aside id="article-toc" role="navigation" class="fixed">
    <div id="article-toc-inner">
        <strong class="sidebar-title">
            目录
        </strong>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if-vs-v-show"><span class="toc-text">v-if vs v-show</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Vue生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">vue双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">vue单向数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom"><span class="toc-text">虚拟dom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84data%E9%80%89%E9%A1%B9%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-text">一个组件的data选项必须是一个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%E9%80%9A%E4%BF%A1"><span class="toc-text">vue中组件之间的传值通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7"><span class="toc-text">计算属性和侦听属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Vuex是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E8%B7%AF%E7%94%B1"><span class="toc-text">vue路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#router%E4%B8%8E-route"><span class="toc-text">$router与$route</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">路由组件传参的3种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router%E7%9A%843%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">vue-router的3种模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E5%92%8Chistory%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">hash和history的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vm-set-%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%93%8D%E5%BA%94"><span class="toc-text">vm.$set()解决对象新增属性不响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">vue过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive"><span class="toc-text">keep-alive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-nextTick-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94"><span class="toc-text">Vue.nextTick 的原理和用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%85%A5"><span class="toc-text">混入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Element-UI-%E5%AE%9E%E7%8E%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">Element UI 实现管理系统页面权限控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proxy%E4%B8%8Eobject-defineProperty"><span class="toc-text">proxy与object.defineProperty</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ECMAScript-6"><span class="toc-text">ECMAScript 6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">操作运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">为什么是单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-%E3%80%81apply-%E5%8C%BA%E5%88%AB"><span class="toc-text">call()、apply()区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-text">什么是闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E4%BB%8E%E6%89%93%E5%BC%80%E5%88%B0%E5%8A%A0%E8%BD%BD"><span class="toc-text">网页从打开到加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-text">优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E9%80%82%E9%85%8D"><span class="toc-text">移动端的适配</span></a></li></ol></li></ol>
    </div>
</aside>


      </div>
        <div class="footer">
  <div class="footer-wrapper">
    <div class="copyright">
      <!-- 
      <span>&copy;</span>
      
      <span>2017 - 2021</span>
      
      <span class="author"><i class="fa fa-user"></i>John Doe</span>
    </div>
    
      <span>由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</span>
    
    
      <span>|</span> <span>主题 - <a target="_blank" rel="noopener" href="https://github.com/littleee/corazon">Corazon</a></span>
      
        <span>v1.0.0</span>
      
     -->
    页脚
  </div>
</div>

    </main>
  </body>
</html>
